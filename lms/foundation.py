"""Foundation file management - accumulated verified Lean code.

The foundation file is the collective memory of verified definitions that
agents can import and build upon. Each generation adds verified artifacts
to this shared foundation, allowing subsequent generations to reuse them
via `import LMS.Foundation` instead of re-implementing from scratch.

This implements the "collective brain" vision: knowledge accumulates across
generations, with each agent building on the verified work of predecessors.
"""

from __future__ import annotations

import json
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from lms.artifacts import Artifact


@dataclass
class FoundationEntry:
    """A single definition/theorem in the foundation file.

    Attributes:
        artifact_id: ID of the artifact that contributed this entry
        name: Name of the definition (e.g., "Category", "CFunctor")
        entry_type: Type of entry (structure, def, theorem, lemma, etc.)
        signature: The type signature line
        lean_code: Full Lean code for this entry
        generation: Generation when this was added
        author: Agent that created this
    """

    artifact_id: str
    name: str
    entry_type: str  # structure, def, theorem, lemma, etc.
    signature: str
    lean_code: str
    generation: int
    author: str

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "artifact_id": self.artifact_id,
            "name": self.name,
            "entry_type": self.entry_type,
            "signature": self.signature,
            "lean_code": self.lean_code,
            "generation": self.generation,
            "author": self.author,
        }

    @classmethod
    def from_dict(cls, d: dict) -> FoundationEntry:
        """Create from dictionary."""
        return cls(
            artifact_id=d["artifact_id"],
            name=d["name"],
            entry_type=d["entry_type"],
            signature=d["signature"],
            lean_code=d["lean_code"],
            generation=d["generation"],
            author=d["author"],
        )


class FoundationFile:
    """Manages the accumulated foundation of verified Lean definitions.

    The foundation file grows across generations:
    - Gen 0: Agent defines Category → saved to Foundation.lean
    - Gen 1: Agent imports Foundation, defines Functor → appended
    - Gen 2: Agent imports Foundation (has Cat, Functor), defines NatTrans → appended
    - ...

    Agents receive context about what's available for import, encouraging
    reuse over re-implementation.

    CONFLICT RESOLUTION:
    When multiple agents define the same core concept (Category, Functor, etc.)
    with incompatible structures, only the FIRST verified definition is kept.
    This "first-mover wins" rule prevents compilation errors from incompatible
    definitions. Future: implement voting on conflicts.
    """

    # Core concepts that should only have one definition
    # Different naming conventions map to the same concept
    CORE_CONCEPTS = {
        "Category": "category",
        "Cat": "category",
        "Functor": "functor",
        "CFunctor": "functor",
        "Fun": "functor",
        "Funct": "functor",
        "NatTrans": "nattrans",
        "NaturalTransformation": "nattrans",
    }

    # Patterns to extract definitions from Lean code
    # Matches: structure Name, def Name, theorem Name, lemma Name, etc.
    # Allows leading whitespace for indented code
    DEFINITION_PATTERN = re.compile(
        r"^\s*(structure|def|theorem|lemma|abbrev|instance|class|inductive)\s+"
        r"([A-Za-z_][A-Za-z0-9_\.]*)"
        r"([^\n]*)",
        re.MULTILINE,
    )

    # Standard imports for the foundation file
    FOUNDATION_HEADER = """/-
LMS Foundation - Accumulated Verified Definitions
This file is auto-generated by the LLM Mathematical Society.
Each section was verified by LEAN before being added.

Usage: import LMS.Foundation
-/

import Mathlib.Tactic.Common
import Mathlib.Logic.Basic
import Mathlib.Logic.Function.Basic
import Mathlib.Data.Nat.Basic
import Mathlib.Algebra.Ring.Basic

universe u v w

namespace LMS.Foundation

"""

    FOUNDATION_FOOTER = """
end LMS.Foundation
"""

    def __init__(self, path: Path) -> None:
        """Initialize foundation file manager.

        Args:
            path: Path to the Foundation.lean file
        """
        self.path = Path(path)
        self.entries: list[FoundationEntry] = []
        self._artifact_ids: set[str] = set()  # Track added artifacts
        self._definition_names: set[str] = set()  # Track defined names to avoid duplicates
        self._claimed_concepts: set[str] = set()  # Track which core concepts have definitions

    def __len__(self) -> int:
        """Return number of entries in foundation."""
        return len(self.entries)

    def add_artifact(self, artifact: Artifact) -> None:
        """Add a verified artifact to the foundation.

        Args:
            artifact: The artifact to add (must be verified with Lean code)

        Raises:
            ValueError: If artifact is not verified or has no Lean code
        """
        if not artifact.verified:
            raise ValueError("Foundation accepts only verified artifacts")
        if not artifact.lean_code:
            raise ValueError("Artifact has no Lean code")

        # Skip duplicates
        if artifact.id in self._artifact_ids:
            return

        # Clean the lean code (remove YAML multiline markers and embedded imports)
        clean_code = artifact.lean_code
        if clean_code.startswith("|"):
            clean_code = clean_code[1:].lstrip("\n")

        # Remove problematic statements that conflict with Foundation wrapper:
        # - import statements (must be at file top, Foundation has common imports)
        # - universe declarations (Foundation header has them)
        # - namespace/end statements (conflict with LMS.Foundation namespace)
        lines = clean_code.split("\n")
        clean_lines = []
        for line in lines:
            stripped = line.strip()
            if stripped.startswith("import "):
                continue
            if stripped.startswith("universe "):
                continue
            # Remove namespace and end statements (they break Foundation wrapper)
            if stripped.startswith("namespace "):
                continue
            if stripped.startswith("end "):
                continue
            clean_lines.append(line)
        clean_code = "\n".join(clean_lines).strip()

        # Extract definitions from the code
        new_entries = self._extract_entries(
            clean_code,
            artifact.id,
            artifact.generation,
            artifact.created_by,
        )

        # Check for INCOMPATIBLE concept conflicts (different names, same concept)
        # e.g., Foundation has "Category", artifact defines "Cat" → reject entire artifact
        # This is different from DUPLICATE definitions (same name) which are just skipped
        for entry in new_entries:
            if entry.entry_type == "structure" and entry.name in self.CORE_CONCEPTS:
                concept = self.CORE_CONCEPTS[entry.name]
                if concept in self._claimed_concepts:
                    # Check if it's a true conflict (different name) or just a duplicate (same name)
                    # Find existing structure name for this concept
                    existing_name = None
                    for existing in self.entries:
                        if (existing.entry_type == "structure" and
                            existing.name in self.CORE_CONCEPTS and
                            self.CORE_CONCEPTS[existing.name] == concept):
                            existing_name = existing.name
                            break

                    if existing_name and existing_name != entry.name:
                        # TRUE CONFLICT: Different names for same concept (e.g., Category vs Cat)
                        # Reject entire artifact to avoid incompatible definitions
                        self._artifact_ids.add(artifact.id)  # Mark as seen to prevent retry
                        return
                    # If same name, it's just a duplicate - will be skipped below

        # Filter and add entries
        unique_entries = []
        for entry in new_entries:
            # Skip if name already exists (duplicate)
            if entry.name in self._definition_names:
                continue

            # Claim any core concepts defined by this entry
            if entry.entry_type == "structure" and entry.name in self.CORE_CONCEPTS:
                self._claimed_concepts.add(self.CORE_CONCEPTS[entry.name])

            unique_entries.append(entry)
            self._definition_names.add(entry.name)

        self.entries.extend(unique_entries)
        self._artifact_ids.add(artifact.id)

    # Pattern to match block comments /- ... -/
    BLOCK_COMMENT_PATTERN = re.compile(r"/-.*?-/", re.DOTALL)

    def _strip_block_comments(self, code: str) -> str:
        """Remove block comments from code for definition detection.

        Block comments are replaced with whitespace of the same length
        to preserve character positions for slicing original code.

        Args:
            code: Lean source code

        Returns:
            Code with block comments replaced by spaces
        """
        result = code
        for match in self.BLOCK_COMMENT_PATTERN.finditer(code):
            # Replace with spaces to preserve positions
            replacement = " " * len(match.group())
            result = result[: match.start()] + replacement + result[match.end() :]
        return result

    def _extract_entries(
        self,
        code: str,
        artifact_id: str,
        generation: int,
        author: str,
    ) -> list[FoundationEntry]:
        """Extract definition entries from Lean code.

        Args:
            code: Lean source code
            artifact_id: ID of the source artifact
            generation: Generation number
            author: Agent ID

        Returns:
            List of extracted FoundationEntry objects
        """
        entries = []

        # Strip block comments to avoid matching definitions inside comments
        code_without_comments = self._strip_block_comments(code)

        # Find all definition positions (using comment-stripped code)
        matches = list(self.DEFINITION_PATTERN.finditer(code_without_comments))

        for i, match in enumerate(matches):
            entry_type = match.group(1)  # structure, def, theorem, etc.
            name = match.group(2)  # Name of the definition
            rest = match.group(3).strip()  # Rest of signature line

            signature = f"{entry_type} {name}{rest}"

            # Extract just this definition's code
            # From this match's start to the next match's start (or end of code)
            start = match.start()
            if i + 1 < len(matches):
                end = matches[i + 1].start()
            else:
                end = len(code)

            definition_code = code[start:end].strip()

            entries.append(
                FoundationEntry(
                    artifact_id=artifact_id,
                    name=name,
                    entry_type=entry_type,
                    signature=signature,
                    lean_code=definition_code,  # Store only this definition's code
                    generation=generation,
                    author=author,
                )
            )

        # If no definitions found, create a single entry for the whole artifact
        if not entries:
            # Use last 12 chars of artifact_id to avoid collisions
            # (all artifacts start with "definition-" so first chars collide)
            unique_suffix = artifact_id[-12:] if len(artifact_id) >= 12 else artifact_id
            entries.append(
                FoundationEntry(
                    artifact_id=artifact_id,
                    name=f"artifact_{unique_suffix}",
                    entry_type="code",
                    signature="",
                    lean_code=code,
                    generation=generation,
                    author=author,
                )
            )

        return entries

    def get_import_statement(self) -> str:
        """Return the import statement agents should use.

        Returns:
            Import statement string
        """
        return "import LMS.Foundation"

    def get_available_definitions(self) -> str:
        """Return a summary of available definitions.

        Returns:
            Human-readable summary of what's in the foundation
        """
        if not self.entries:
            return "No definitions available yet."

        lines = []
        # Group by type
        by_type: dict[str, list[FoundationEntry]] = {}
        for entry in self.entries:
            if entry.entry_type not in by_type:
                by_type[entry.entry_type] = []
            by_type[entry.entry_type].append(entry)

        for entry_type, type_entries in sorted(by_type.items()):
            lines.append(f"\n{entry_type.upper()}S:")
            for entry in type_entries:
                lines.append(f"  - {entry.name} (gen {entry.generation})")
                if entry.signature:
                    # Show first part of signature
                    sig = entry.signature[:80]
                    if len(entry.signature) > 80:
                        sig += "..."
                    lines.append(f"    {sig}")

        return "\n".join(lines)

    def get_context_for_agent(self) -> str:
        """Get full context string for agent prompts.

        This tells agents what's available for import and how to use it.

        Returns:
            Context string to include in agent prompts
        """
        if not self.entries:
            return """═══════════════════════════════════════════════════════════════════════════════
                            FOUNDATION: EMPTY
═══════════════════════════════════════════════════════════════════════════════
No verified definitions yet. You are starting from scratch.
Create foundational definitions that future generations can build upon.
═══════════════════════════════════════════════════════════════════════════════"""

        lines = [
            "═══════════════════════════════════════════════════════════════════════════════",
            "                    VERIFIED FOUNDATION (import LMS.Foundation)",
            "═══════════════════════════════════════════════════════════════════════════════",
            "",
            "The following definitions are VERIFIED and available for import.",
            "USE THEM! Do not redefine what already exists.",
            "",
            f"To use: Add `{self.get_import_statement()}` at the top of your code.",
            "",
        ]

        # Group entries by generation for clarity
        by_gen: dict[int, list[FoundationEntry]] = {}
        for entry in self.entries:
            if entry.generation not in by_gen:
                by_gen[entry.generation] = []
            by_gen[entry.generation].append(entry)

        for gen in sorted(by_gen.keys()):
            gen_entries = by_gen[gen]
            lines.append(f"── Generation {gen} ──")
            for entry in gen_entries:
                lines.append(f"  {entry.entry_type} {entry.name}")
                # Show key fields for structures
                if entry.entry_type == "structure":
                    # Extract field names from code
                    field_match = re.findall(
                        r"^\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*:",
                        entry.lean_code,
                        re.MULTILINE,
                    )
                    if field_match:
                        fields = ", ".join(field_match[:5])
                        if len(field_match) > 5:
                            fields += ", ..."
                        lines.append(f"    fields: {fields}")
            lines.append("")

        lines.append("═══════════════════════════════════════════════════════════════════════════════")

        return "\n".join(lines)

    def save(self) -> None:
        """Save foundation to Lean file and metadata JSON."""
        # Ensure directory exists
        self.path.parent.mkdir(parents=True, exist_ok=True)

        # Build Lean file content
        lean_content = self.FOUNDATION_HEADER

        # Write each unique entry's code
        # Group by artifact but only write code for unique definitions
        seen_artifacts: set[str] = set()
        written_names: set[str] = set()

        for entry in self.entries:
            # Skip if this definition name was already written
            if entry.name in written_names:
                continue

            if entry.artifact_id not in seen_artifacts:
                seen_artifacts.add(entry.artifact_id)
                lean_content += f"\n-- From {entry.artifact_id} (gen {entry.generation}, {entry.author})\n"

            # Write only this entry's code
            lean_content += entry.lean_code
            lean_content += "\n"
            written_names.add(entry.name)

        lean_content += self.FOUNDATION_FOOTER

        # Write Lean file
        self.path.write_text(lean_content)

        # Write metadata JSON
        metadata = {
            "entries": [e.to_dict() for e in self.entries],
            "artifact_ids": list(self._artifact_ids),
        }
        metadata_path = self.path.with_suffix(".json")
        metadata_path.write_text(json.dumps(metadata, indent=2))

    @classmethod
    def load(cls, path: Path) -> FoundationFile:
        """Load foundation from saved metadata.

        Args:
            path: Path to Foundation.lean file

        Returns:
            Loaded FoundationFile
        """
        foundation = cls(path)

        metadata_path = path.with_suffix(".json")
        if metadata_path.exists():
            metadata = json.loads(metadata_path.read_text())
            foundation.entries = [
                FoundationEntry.from_dict(e) for e in metadata.get("entries", [])
            ]
            foundation._artifact_ids = set(metadata.get("artifact_ids", []))
            # Rebuild definition names from loaded entries
            foundation._definition_names = {e.name for e in foundation.entries}
            # Rebuild claimed concepts from loaded entries
            for entry in foundation.entries:
                if entry.entry_type == "structure" and entry.name in cls.CORE_CONCEPTS:
                    foundation._claimed_concepts.add(cls.CORE_CONCEPTS[entry.name])

        return foundation
